// Generated by CoffeeScript 1.4.0
(function() {
  var Categorisation, Position, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  if ((_ref = window.nicetohave) == null) {
    window.nicetohave = {};
  }

  Position = (function() {

    function Position(v) {
      this.toString = __bind(this.toString, this);

      this.hasValue = __bind(this.hasValue, this);

      var _this = this;
      this._v = ko.observable(v != null ? this.clamp(v) : null);
      this.value = ko.computed({
        read: this._v,
        write: function(v) {
          return _this._v(_this.clamp(v));
        }
      });
    }

    Position.prototype.hasValue = function() {
      return this._v() != null;
    };

    Position.prototype.clamp = function(v) {
      return Math.min(1.0, Math.max(0.0, v));
    };

    Position.prototype.toString = function() {
      if (this.hasValue()) {
        return this.value().toString();
      } else {
        return "unknown";
      }
    };

    return Position;

  })();

  Categorisation = (function() {

    function Categorisation(card) {
      this.axis = __bind(this.axis, this);

      var _this = this;
      this.card = card;
      this._axes = ko.computed(function() {
        var axes, comment, _i, _len, _ref1;
        axes = {
          "risk": new Position(),
          "value": new Position()
        };
        if (_this.card.hasComments()) {
          _ref1 = _this.card.comments();
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            comment = _ref1[_i];
            if (_this._parseComment(comment.text(), axes)) {
              break;
            }
          }
        }
        return axes;
      });
      this.axes = ko.computed(function() {
        return [
          {
            name: "risk",
            position: _this._axes()["risk"]
          }, {
            name: "value",
            position: _this._axes()["value"]
          }
        ];
      });
    }

    Categorisation.prototype.axis = function(name) {
      return this._axes()[name];
    };

    Categorisation.prototype._parseComment = function(text, axes) {
      var axis, match, matched, re, value;
      re = /(risk|value):([\d.]+)/g;
      matched = false;
      while ((match = re.exec(text))) {
        matched = true;
        axis = match[1];
        value = parseFloat(match[2]);
        axes[axis] = new Position(value);
      }
      return matched;
    };

    return Categorisation;

  })();

  window.nicetohave.Categorisation = Categorisation;

}).call(this);
