// Generated by CoffeeScript 1.4.0
(function() {
  var Categorisation, CommentPosition, EditablePosition, Position, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  if ((_ref = window.nicetohave) == null) {
    window.nicetohave = {};
  }

  Position = (function() {

    function Position(v) {
      this.hasValue = __bind(this.hasValue, this);
      this._v = ko.observable(v != null ? this.clamp(v) : null);
    }

    Position.prototype.hasValue = function() {
      return this.value() != null;
    };

    Position.prototype.clamp = function(v) {
      return Math.min(1.0, Math.max(0.0, v));
    };

    return Position;

  })();

  CommentPosition = (function(_super) {

    __extends(CommentPosition, _super);

    function CommentPosition(v) {
      var _this = this;
      CommentPosition.__super__.constructor.call(this, v);
      this.value = ko.computed({
        read: this._v,
        write: function(v) {
          return _this._v(_this.clamp(v));
        }
      });
    }

    return CommentPosition;

  })(Position);

  EditablePosition = (function(_super) {

    __extends(EditablePosition, _super);

    function EditablePosition(commentPos) {
      var _this = this;
      EditablePosition.__super__.constructor.call(this, null);
      this.value = ko.computed({
        read: function() {
          if (_this._v() != null) {
            return _this._v();
          } else {
            return commentPos.value();
          }
        },
        write: function(v) {
          return _this._v(_this.clamp(v));
        }
      });
      this.hasEdits = ko.computed(function() {
        return _this.value() !== commentPos.value();
      });
    }

    return EditablePosition;

  })(Position);

  Categorisation = (function() {

    function Categorisation(card) {
      this._updateCommentValues = __bind(this._updateCommentValues, this);

      this.saveEdits = __bind(this.saveEdits, this);

      this.axis = __bind(this.axis, this);

      var _this = this;
      this.card = card;
      this.commentRisk = new CommentPosition();
      this.commentValue = new CommentPosition();
      this.editableRisk = new EditablePosition(this.commentRisk);
      this.editableValue = new EditablePosition(this.commentValue);
      this._updateCommentValues(this.card.comments());
      this.card.comments.subscribe(this._updateCommentValues);
      this.axes = ko.computed(function() {
        return [
          {
            name: "risk",
            position: _this.editableRisk
          }, {
            name: "value",
            position: _this.editableValue
          }
        ];
      });
      this.hasEdits = ko.computed(function() {
        return _this.editableRisk.hasEdits() || _this.editableValue.hasEdits();
      });
    }

    Categorisation.prototype.axis = function(name) {
      if (name === "risk") {
        return this.editableRisk;
      } else if (name === "value") {
        return this.editableValue;
      } else {
        return null;
      }
    };

    Categorisation.prototype.saveEdits = function() {
      var formatted;
      if (this.hasEdits()) {
        formatted = [];
        if (this.editableRisk.hasEdits()) {
          formatted.push("risk:" + (this.editableRisk.value()));
        }
        if (this.editableValue.hasEdits()) {
          formatted.push("value:" + (this.editableValue.value()));
        }
        return this.card.addComment(new nicetohave.Comment(formatted.join(" ")));
      }
    };

    Categorisation.prototype._updateCommentValues = function(comments) {
      var axes, comment, foundValue, _i, _len, _results;
      foundValue = {
        "risk": false,
        "value": false
      };
      axes = {
        "risk": this.commentRisk,
        "value": this.commentValue
      };
      _results = [];
      for (_i = 0, _len = comments.length; _i < _len; _i++) {
        comment = comments[_i];
        _results.push(this._parseComment(comment.text(), axes, foundValue));
      }
      return _results;
    };

    Categorisation.prototype._parseComment = function(text, axes, foundValue) {
      var axis, match, re, _results;
      re = /(risk|value):([\d.]+)/g;
      _results = [];
      while ((match = re.exec(text))) {
        axis = match[1];
        if (!foundValue[axis]) {
          axes[axis].value(parseFloat(match[2]));
          _results.push(foundValue[axis] = true);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return Categorisation;

  })();

  window.nicetohave.Categorisation = Categorisation;

}).call(this);
